


Network Working Group                                            Gu, Ed.
Request for Comments: 2                                               Li
Category: Standards Track                                             Li
                                                                     Qin
                                                                     Xie
                                          JHU Network Security Fall 2017
                                                           November 2017


                    Playground Request For Comments

Abstract

   The PLS protocol (Playground Layer Security Protocol) is designed to
   proide secure communication between client and server.  This PRFC
   specifies the architecture and detailed implementations of PLS.

Status of this Memo

   This document specifies a Playgrounds standards track protocol for
   the Playground Experiment, and requests discussion and suggestions
   for improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (c) 2017 SETH JAMES NIELSON.  All rights reserved.

   This document is used solely for educational purposes.  Any citations
   within this document are also for educational purposes and also for
   technical reference.  If any of these cited elements are protected
   under copyright, their inclusion here falls under Fair Use
   provisions.



















Gu, et al.                   Standards Track                    [Page 1]

RFC 2                            PRFC's                    November 2017


Table of Contents

   1.  INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Requirement Terminology  . . . . . . . . . . . . . . . . .  3
     1.2.  Requirement Cryptography . . . . . . . . . . . . . . . . .  3
       1.2.1.  RSA  . . . . . . . . . . . . . . . . . . . . . . . . .  3
       1.2.2.  SHA1 . . . . . . . . . . . . . . . . . . . . . . . . .  3
       1.2.3.  AES  . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.3.  Certificate Authorization  . . . . . . . . . . . . . . . .  4
   2.  Packet Description . . . . . . . . . . . . . . . . . . . . . .  4
     2.1.  Elements of the Internetwork System  . . . . . . . . . . .  5
     2.2.  PlsHello Packet  . . . . . . . . . . . . . . . . . . . . .  5
     2.3.  PlsKeyExchange Packet  . . . . . . . . . . . . . . . . . .  5
     2.4.  PlsHandshakeDone Packet  . . . . . . . . . . . . . . . . .  6
     2.5.  PlsData Packet . . . . . . . . . . . . . . . . . . . . . .  6
     2.6.  PlsClose Packet  . . . . . . . . . . . . . . . . . . . . .  6
   3.  Session Life . . . . . . . . . . . . . . . . . . . . . . . . .  7
     3.1.  Session Establishment  . . . . . . . . . . . . . . . . . .  7
       3.1.1.  Authentication . . . . . . . . . . . . . . . . . . . .  7
       3.1.2.  Key Derivation . . . . . . . . . . . . . . . . . . . .  8
       3.1.3.  Error Handling . . . . . . . . . . . . . . . . . . . .  8
     3.2.  Data Transmission  . . . . . . . . . . . . . . . . . . . .  8
     3.3.  Session Termination  . . . . . . . . . . . . . . . . . . . 10
   4.  Normative References . . . . . . . . . . . . . . . . . . . . . 10
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 10
   Intellectual Property and Copyright Statements . . . . . . . . . . 12

























Gu, et al.                   Standards Track                    [Page 2]

RFC 2                            PRFC's                    November 2017


1.  INTRODUCTION

   The primary goal of PLS protocol is to provide privacy and data
   integrity between communication.  The PLS protocol is based on the
   PLAYGROUND framework, designed by Dr. Seth James Nielson.  It is
   useful for us to learn a lot about security attacks and defenses by
   using this framework.

   In this lab, PLS protocol (Playground Layer Security Protocol)
   consists of the following parts:

   1.  Connection establishment which is implemented by using a six-way
   handshake.

   2.  Data transmission between protocols

   3.  Connection termination

   The format of this document, as well as many terminologies in this
   document, is referred to Requests for Comments: 5246 Transport Layer
   Security (TLS) Protocol Version 1.2.[RFC5246] Also, the
   implementations of PLS are based on the implementations of TLS.

1.1.  Requirement Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [REQ].

1.2.  Requirement Cryptography

1.2.1.  RSA

   In this lab, we use RSA.  RSA (Rivest Shamir Adleman) is one of the
   first practical public-key cryptosystems and is widely used for
   secure data transmission.  In such a cryptosystem, the encryption key
   is public and it is different from the decryption key which is kept
   secret (private).  For example, RSA is used for PreKey exchange, and
   the PreKey is generated in the following: the client uses RSA - 2048
   with OAEP padding of the server public key, similarly, the server
   uses RSA - 2048 with OAEP padding of the client public key.

1.2.2.  SHA1

   In cryptography, SHA-1 (Secure Hash Algorithm 1) is a cryptographic
   hash function designed by the United States National Security Agency
   and is a U.S. Federal Information Processing Standard published by
   the United States NIST.



Gu, et al.                   Standards Track                    [Page 3]

RFC 2                            PRFC's                    November 2017


1.2.3.  AES

   The Advanced Encryption Standard (AES), also known by its original
   name Rijndael, is a specification for the encryption of electronic
   data established by the U.S. National Institute of Standards and
   Technology (NIST) in 2001.

1.3.  Certificate Authorization

   In order to achieve the authentication of both side, we need to make
   the public key of both side have a valid certification.  In the PLSP,
   an authenticated party could generate other certifications for the
   lower level, and the highest level has to be the root.

   In this lab, the root cert is given.  And it needs to sign another
   cert.  The specific process is in the following: First, the private
   keys are generated by using RSA-2048.  Then, the certificate signing
   request for your intermediate certificate authorities need to be
   made.  Enter the details as follows :

   Country Name: US

   State or Province Name: MD

   Locality Name: Baltimore

   Organization Name: JHU NetworkSecurityFall2017

   Organizational Unit Name: PETF

   Common Name: 20174.1.n

   The "n" in "Common Name" denotes a value from the Playground address.
   Choose any random number between 1 and 65536.


2.  Packet Description

   In this section, we will describe the packets that used in the PLS
   layer.  There are several different types of packet that used in PLS
   layer.  We will describe how each packet defined, how each packet
   implemented, and how each packet will be used.

   We define the PLSPacket class as the basic class of all other PLS
   packets and the PLSPacket is descendent of the PacketType class.  In
   other words, the PLAPacket is sub-class of PacketType class and other
   PLS packets class are sub-classes of PLSPacket.




Gu, et al.                   Standards Track                    [Page 4]

RFC 2                            PRFC's                    November 2017


2.1.  Elements of the Internetwork System

   The environment consists of hosts connected to networks.  Here, it is
   assumed that the networks may be local networks or virtual
   networks(e.g. class VM).  Besides, the networks are based on packet
   switching.  The Internetwork system provides two-way data flow
   between ports.

   The packet is used to transmit data between ports.  The format of
   data blocks will be wrapped in the PEEP.  Thus, we do not concern the
   format.

   Hosts are the sources and destinations of packets.  We can send and
   receive packets what we need via hosts.

2.2.  PlsHello Packet

   This type of packet is used in the PLS layer's handshake process.  It
   is used specifically during the creation of connection and session
   between client end and server end.  Since it indirectly inherits from
   PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION,
   and FIELDS attributes.  We define FIELDS to be two attributes, that
   is "Nonce" and "Certs".

   "Nonce" is defined as a type of UINT64 and it is a 64-bit random
   integer.  It is used to identify the session between both sides and
   also to generate keys that will be used for late encryption.  "Certs"
   is the certificates used by the client end and server end to validate
   and identify the authorization of the other side.  A certificate is
   untruthful unless it is signed by a truthful third-party, which is
   CA(Certificate Authority).  In this case, the CA we trust is the
   teacher and the TA for this course.

2.3.  PlsKeyExchange Packet

   This type of packet is also used in the PLS layer's handshake
   process.  It is used specifically during the client end and server
   end already sent the PlsHello packet.  Since it indirectly inherits
   from PacketType class, it has DEFINITION_IDENTIFIER,
   DEFINITION_VERSION, and FIELDS attributes.  We define FIELDS to be
   two attributes, that is "PreKey" and "NoncePlusOne".

   "NoncePlusOne" is defined as a type of UINT64 and it is a 64-bit
   integer.  The value of this field is the value of "Nonce" from
   previous packet plus one.  The purpose of this field is to identify
   the session of both sides and serve as an acknowledgment for both
   sides.  "PreKey" is defined as a type of BUFFER and it has 128 bit.
   As one of the seeds, it is used to generate a series of keys and



Gu, et al.                   Standards Track                    [Page 5]

RFC 2                            PRFC's                    November 2017


   IVs(Initialization Vector) that will be used in later encryption,
   such as Encryption Keys for both sides, MAC Keys for both sides, and
   IVs for both sides.  It will be encrypted under the public key
   contained in the certificate of the other side when it was sent to
   the other side.

2.4.  PlsHandshakeDone Packet

   This type of packet is also used in the PLS layer's handshake
   process.  It is used specifically during the client end and server
   end already sent the PlsKeyExchange packet.  Since it indirectly
   inherits from PacketType class, it has DEFINITION_IDENTIFIER,
   DEFINITION_VERSION, and FIELDS attributes.  We define FIELDS to be
   only one attribute, that is "ValidationHash".

   "ValidationHash" is the hash of the previous messages, in other
   words, the hash of the previous packets that used in the handshake
   process.The purpose of this field is to make sure the packets that
   have been sent are in integrity.

   We will describe more detailed information in the later section about
   the handshake process.

2.5.  PlsData Packet

   This type of packet is used in the PLS layer's data transmission
   process.  It is used specifically by the client end and server end
   after the handshake process is done.  Since it indirectly inherits
   from PacketType class, it has DEFINITION_IDENTIFIER,
   DEFINITION_VERSION, and FIELDS attributes.  We define FIELDS to be
   two attributes, that is "Ciphertext" and "Mac".

   "Ciphertext" is the result of encrypting the plaintext data sent
   between both sides.  It is generated by running the encryption engine
   on both sides.  "Mac" is Message Authentication Code, which is used
   to make sure the integrity of data.  It is generated by running the
   MAC engine on both sides.

   We will describe more detail information in the later section about
   the data transmission process.

2.6.   PlsClose Packet

   This type of packet is used in closing the session between both
   sides.  Since it indirectly inherits from PacketType class, it has
   DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes.  We
   define FIELDS to be an optional "Error" type.




Gu, et al.                   Standards Track                    [Page 6]

RFC 2                            PRFC's                    November 2017


   If either client or server detects an error, it will send a PlsClose
   Packet with an error message.  The text of the error message is
   implementation specific, but the presence of an error message
   indicates that it was not a normal termination.  And also, when it
   comes to a normal shutdown, that is either the client end to the
   server end want to close the session, the "Error" field will be
   omitted.


3.  Session Life

3.1.  Session Establishment

   The Client sends the Server a hello, which is a PlsHello packet.
   This client hello contains a "Client-Nonce", which is 64 bits random
   number, and list of certificates.  The first certificate must be
   root's certificate, followed by any other certificates required for
   authentication.  Correspondingly, the server sends a hello to the
   client, which is the same type of package with the corresponding
   elements of the server side information.  In this stage, both sides
   will make sure they are talking to the right person and they will
   also get the other side's public key.

   Then, in the next section in the handshake process, the Client sends
   the Server a Key Exchange Message, which is a PlsKeyExchange packet.
   This packet contains the Public key of the Client side (128 bits),
   and the Server-Nonce sent in the second phase plus one.  In this
   phase, the Public key of the Client side is encrypted under the
   public key contained in Server's certificate.  And the data that will
   be used by the client and the server to generate keys.
   Correspondingly, the server sends a hello to the client, which is the
   same type of package with the corresponding elements of the server
   side information.

   The client then sends a PlsHandshakeDone packet after the
   PlsKeyExchange packets are sent and received.  The Handshake Finished
   Message contains the hash of the previous four handshake messages
   phase 1 through phase 4.  It is the same as the server side, but they
   could send the PlsHandshakeDone package at the same time.

   After all the handshake process is finished, both side will
   accomplish authentication and generate the agreed symmetric
   encryption key.

3.1.1.  Authentication

   In order to achieve the authentication of both side, we need to make
   the public key of both sides have a valid certification.  In the



Gu, et al.                   Standards Track                    [Page 7]

RFC 2                            PRFC's                    November 2017


   PLSP, an authenticated party could generate other certifications for
   the lower level, and the highest level has to be the root.

3.1.2.  Key Derivation

   They both side need to make an agreement on the symmetric key.  They
   need to derive a Client Encryption Key, a server encryption key,
   which serves as the client's decryption key, a client MAC key and a
   server MAC key, which serves as the client's verification key.

   Each type of the key is 128bits long.  Besides, each side also has to
   generate a Client encryption IV and IVs Server encryption IV, each
   also of size 128bits.

   To generate these keys and IVs, we need a consecutive hashing
   process.  The first hash function seed is the ["PLS1.0" + Client-
   Nonce + Server Nonce + client public key + server public key].  We
   need to generate a stream using repeated SHA1 hashing of this seed.
   Then, we need to take the output of this hash function as the input
   seed of the SHA1 hashing stream.  This process has to repeat for four
   times so that we could generate 800 bits data.

   Then, in order to derive the keys and IVs from the data we got.
   These 800 bits can be cut up to create the 768 bits of keys and IV's
   described above (with 32 bits discarded).  We take the first 128 bits
   to be AES encryption key of the client, the encryption key of the
   server is the next 128 bits, the following 128 bits is the IV of
   client side, the IV of the server is the 128 bits after, the MAC key
   of the client is the next 128 bits, and the MAC key of the server is
   the next 128 bits.  Finally, the left 32 bits are discarded.

3.1.3.  Error Handling

   If either client or server detects an error, they are expected to
   terminate the session, because PLSP is above a reliable transmission
   layer, any transmission error is not likely happened naturally.  And
   terminate this session is the most secure way to make sure
   confidentially transmission.

   PLSP should send a PlsClose packet with an error message.  And when
   the other side of PSLP receive the package, it will also terminate
   its connection.

3.2.  Data Transmission

   After either side has sent the handshake complete message, it can
   begin to send data.  Each side creates an encryption and decryption
   engine corresponding with keys and IV:



Gu, et al.                   Standards Track                    [Page 8]

RFC 2                            PRFC's                    November 2017


   For the client, the encryption engine is configured with client
   encryption key EKc and client IVc as the initial counter value.  The
   decryption engineA is configured with server decryption key EKs and
   server IVs as the initial counter value.

   For the server, the keys and IV's are reversed between the two
   engines.  A  Each side also creates an HMAC-SHA1 MAC engine and
   Verification engine.

   For the client, the MAC engine is configured with key MKc.  The
   verification engine is configured with key MKs.

   For the server, the keys are reversed between the two engines.  The
   encryption engine is configured with server encryption key EKc and
   client IVc as the initial counter value.  The decryption engine is
   configured with client decryption key EKs and server IVs as the
   initial counter value.

   To send data, the plain text P is encrypted by the encryption engine
   to produce cipher text C. C is then passed to the MAC engine to
   produce verification code V. This data is sent in a PLS Data message
   (C, V).

   When data is received, C is extracted and passed to the Verification
   engine to produce reference verification code V'.  If V does not
   match V', the packet is discarded, but the connectionA does not need
   to be closed.  However, an implementation can choose to terminate the
   connection according to its own policy (e.g., if too many bad packets
   are received in a row).  If it closes the connection abnormally, it
   MUST send a PlsClose packet with an error message of its choosing.

   If V == V', the ciphertext C is passed to the Decryption engine to
   produce P'.  This data is passed to the higher layer.

   All data is encrypted using AES-128 in CTR mode.  The encryption
   engine should be configured with the IV as the initial counter (IVc
   for client, IVs for server).

   Data sent must be encrypted with the appropriate encryption key (EKc
   for client, EKs for server).  The cipher text is then MAC'd using
   HMAC-SHA1.

   A  Either side can close the session.  To do so, it MUST send a
   PlsClose packet.  If it is a normal shutdown, it MUST send the
   PlsClose packet without any error message.  If either side receive an
   error message, they MUST shut down the connection.





Gu, et al.                   Standards Track                    [Page 9]

RFC 2                            PRFC's                    November 2017


3.3.  Session Termination

   Both the client and the server can request termination by sending a
   PlsClose packet.  When one side wants to close the session after all
   the data has been send successfully, it sends out a PlsClose packet
   to another side without the error message.  The other side receives
   the packet and then closes.

   If the client side or the server side receives an error message
   during handshake or data transmission, for example, an unexpected
   nounce or certification, it knows that there exists an error.  It
   must send a PlsClose packet to another side with a string type
   message to explain what the error is.  This procedure terminates the
   session.  The connection is closed to avoid error.


4.  Normative References

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, DOI 10.17487/
              RFC5246, August 2008,
              <https://www.rfc-editor.org/info/rfc5246>.


Authors' Addresses

   Qiyang Gu (editor)
   JHU Network Security Fall 2017

   Phone: +1 443-939-5604
   Email: qiyanggu@jhu.edu


   Binjie Li
   JHU Network Security Fall 2017

   Phone: +1 443-563-8366
   Email: bli38@jhu.edu


   Zhiyuan Li
   JHU Network Security Fall 2017

   Phone: +1 443-531-9661
   Email: zli108@jhu.edu






Gu, et al.                   Standards Track                   [Page 10]

RFC 2                            PRFC's                    November 2017


   Mengqi Qin
   JHU Network Security Fall 2017

   Phone: +1 443-938-6891
   Email: mqin2@jhu.edu


   Yiming Xie
   JHU Network Security Fall 2017

   Phone: +1 443-635-9868
   Email: yxie32@jh.edu







































Gu, et al.                   Standards Track                   [Page 11]

RFC 2                            PRFC's                    November 2017


Full Copyright Statement

   Copyright (C) Seth James Nielson (2017).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the PLAYGROUND experiment or
   other associated organizations, except by explicit permission.

   The limited permissions granted above are perpetual and will not be
   revoked by SETH JAMES NIELSON or his successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and SETH JAMES NIELSON and associated academic
   institutions DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The PLAYGROUND framework and student submissions for PLAYGROUND are
   intended to be free of any intellectual property conflicts.  All
   submitting parties, especially students, are not allowed to submit
   source code, specifications, or other components that are known to be
   protected by copyright, patents, or other IP mechanisms.  Students
   submitting creative content grant shared rights and ownership of
   their content to the PLAYGROUND project.  Specifically, any
   submission can be used in future educational settings including
   subsequent PLAYGROUND experiments.

   Any interested party is invited to bring to the experiment director's
   attention any copyrights, patents or patent applications, or other
   proprietary rights which may cover technology that may be currently
   in use without permission.

   It should be noted that these statements have not been reviewed by
   legal counsel.  Moreover, the academic institutions at which
   PLAYGROUND experiments take place may have additional or even
   conflicting copyright and intellectual property rules.  Accordingly,
   concerned parties may need to contact their own lawyer and/or
   resources at their institution to understand the rights and



Gu, et al.                   Standards Track                   [Page 12]

RFC 2                            PRFC's                    November 2017


   limitations associated with code donated to a PLAYGROUND experiment.


















































Gu, et al.                   Standards Track                   [Page 13]


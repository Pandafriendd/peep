<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [


<!ENTITY RFC5246 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="prfc2" ipr="playgroundStd_v1_0" number="2">
    <front>
        <title abbrev="PRFC's">Playground Request For Comments</title>
        <author fullname="Qiyang Gu" role="editor" surname="Gu">
            <organization>JHU Network Security Fall 2017</organization>
            <address>
                <phone>+1 443-939-5604</phone>
                <email>qiyanggu@jhu.edu</email>
            </address>
        </author>
        <author fullname="Binjie Li" surname="Li">
            <organization>JHU Network Security Fall 2017</organization>
            <address>
                <phone>+1 443-563-8366</phone>
                <email>bli38@jhu.edu</email>
            </address>
        </author>
        <author fullname="Zhiyuan Li" surname="Li">
            <organization>JHU Network Security Fall 2017</organization>
            <address>
                <phone>+1 443-531-9661</phone>
                <email>zli108@jhu.edu</email>
            </address>
        </author>
        <author fullname="Mengqi Qin" surname="Qin">
            <organization>JHU Network Security Fall 2017</organization>
            <address>
                <phone>+1 443-938-6891</phone>
                <email>mqin2@jhu.edu</email>
            </address>
        </author>
        <author fullname="Yiming Xie" surname="Xie">
            <organization>JHU Network Security Fall 2017</organization>
            <address>
                <phone>+1 443-635-9868</phone>
                <email>yxie32@jh.edu</email>
            </address>
        </author>
        <date year="2017" />
        <area>General</area>
        <workgroup>Playground Experiment Director</workgroup>
        <keyword>PRFC</keyword>
        <abstract>
            <t> The PLS protocol (Playground Layer Security Protocol) is designed to proide secure communication between client and server. This PRFC specifies the architecture and detailed implementations of PLS.</t>
        </abstract>
    </front>
    <middle>
        <section title="INTRODUCTION">
            <t>The primary goal of PLS protocol is to provide privacy and data integrity between communication. The PLS protocol is based on the PLAYGROUND framework, designed by Dr. Seth James Nielson. It is useful for us to learn a lot about security attacks and defenses by using this framework. </t>

            <t>In this lab, PLS protocol (Playground Layer Security Protocol) consists of the following parts:</t>
            <t>1. Connection establishment which is implemented by using a six-way handshake.</t>
            <t>2. Data transmission between protocols</t>
            <t>3. Connection termination </t>

            <t>The format of this document, as well as many terminologies in this document, is referred to Requests for Comments: 5246 Transport Layer Security (TLS) Protocol Version 1.2.<xref target="RFC5246"></xref> Also, the implementations of PLS are based on the implementations of TLS.</t>

            <section title="Requirement Terminology">
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [REQ].</t>

            </section>
            <section title="Requirement Cryptography">
                <section title="RSA">
                <t>In this lab, we use RSA. RSA (Rivest Shamir Adleman) is one of the first practical public-key cryptosystems and is widely used for secure data transmission. In such a cryptosystem, the encryption key is public and it is different from the decryption key which is kept secret (private). For example, RSA is used for PreKey exchange, and the PreKey is generated in the following: the client uses RSA - 2048 with OAEP padding of the server public key, similarly, the server uses RSA - 2048 with OAEP padding of the client public key.</t>
                </section>
                <section title="SHA1">
                <t>In cryptography, SHA-1 (Secure Hash Algorithm 1) is a cryptographic hash function designed by the United States National Security Agency and is a U.S. Federal Information Processing Standard published by the United States NIST.</t>
                </section>
                <section title="AES">
                <t>The Advanced Encryption Standard (AES), also known by its original name Rijndael, is a specification for the encryption of electronic data established by the U.S. National Institute of Standards and Technology (NIST) in 2001.</t>
                </section>

            </section>
            <section title="Certificate Authorization">
                <t>In order to achieve the authentication of both side, we need to make the public key of both side have a valid certification. In the PLSP, an authenticated party could generate other certifications for the lower level, and the highest level has to be the root.</t>
                <t>In this lab, the root cert is given. And it needs to sign another cert. The specific process is in the following:
                First, the private keys are generated by using RSA-2048. Then, the certificate signing request for your intermediate certificate authorities need to be made. Enter the details as follows :</t>
                <t>Country Name: US</t>
                <t>State or Province Name: MD</t>
                <t>Locality Name: Baltimore</t>
                <t>Organization Name: JHU NetworkSecurityFall2017</t>
                <t>Organizational Unit Name: PETF</t>
                <t>Common Name: 20174.1.n</t>
                <t>The "n" in "Common Name" denotes a value from the Playground address. Choose any random number between 1 and 65536.</t>
            </section>
        </section>

        <section title="Packet Description">
        <t>In this section, we will describe the packets that used in the PLS layer. There are several different types of packet that used in PLS layer. We will describe how each packet defined, how each packet implemented, and how each packet will be used. </t>

        <t>We define the PLSPacket class as the basic class of all other PLS packets and the PLSPacket is descendent of the PacketType class. In other words, the PLAPacket is sub-class of PacketType class and other PLS packets class are sub-classes of PLSPacket.</t>
            <section title="Elements of the Internetwork System">
                <t>The environment consists of hosts connected to networks. Here, it is assumed that the networks may be local networks or virtual networks(e.g. class VM). Besides, the networks are based on packet switching. The Internetwork system provides two-way data flow between ports.</t>

                <t>The packet is used to transmit data between ports. The format of data blocks will be wrapped in the PEEP. Thus, we do not concern the format.</t>

                <t>Hosts are the sources and destinations of packets. We can send and receive packets what we need via hosts.</t>
            </section>
            <section title="PlsHello Packet">
                <t>This type of packet is used in the PLS layer's handshake process. It is used specifically during the creation of connection and session between client end and server end. Since it indirectly inherits from PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes. We define FIELDS to be two attributes, that is "Nonce" and "Certs".</t>
                <t>"Nonce" is defined as a type of UINT64 and it is a 64-bit random integer. It is used to identify the session between both sides and also to generate keys that will be used for late encryption. "Certs" is the certificates used by the client end and server end to validate and identify the authorization of the other side. A certificate is untruthful unless it is signed by a truthful third-party, which is CA(Certificate Authority). In this case, the CA we trust is the teacher and the TA for this course.</t>
            </section>
            <section title="PlsKeyExchange Packet">
                <t>This type of packet is also used in the PLS layer's handshake process. It is used specifically during the client end and server end already sent the PlsHello packet. Since it indirectly inherits from PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes. We define FIELDS to be two attributes, that is "PreKey" and "NoncePlusOne".</t>
                <t>"NoncePlusOne" is defined as a type of UINT64 and it is a 64-bit integer. The value of this field is the value of "Nonce" from previous packet plus one. The purpose of this field is to identify the session of both sides and serve as an acknowledgment for both sides. "PreKey" is defined as a type of BUFFER and it has 128 bit. As one of the seeds, it is used to generate a series of keys and IVs(Initialization Vector) that will be used in later encryption, such as Encryption Keys for both sides, MAC Keys for both sides, and IVs for both sides. It will be encrypted under the public key contained in the certificate of the other side when it was sent to the other side.</t>
            </section>

            <section title="PlsHandshakeDone Packet">
                <t>This type of packet is also used in the PLS layer's handshake process. It is used specifically during the client end and server end already sent the PlsKeyExchange packet. Since it indirectly inherits from PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes. We define FIELDS to be only one attribute, that is "ValidationHash".</t>
               
                <t>"ValidationHash" is the hash of the previous messages, in other words, the hash of the previous packets that used in the handshake process.The purpose of this field is to make sure the packets that have been sent are in integrity.</t>
                <t> We will describe more detailed information in the later section about the handshake process.</t>
            </section>

            <section title="PlsData Packet">
                <t>This type of packet is used in the PLS layer's data transmission process. It is used specifically by the client end and server end after the handshake process is done. Since it indirectly inherits from PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes. We define FIELDS to be two attributes, that is "Ciphertext" and "Mac".</t>
                
                <t>
                "Ciphertext" is the result of encrypting the plaintext data sent between both sides. It is generated by running the encryption engine on both sides. "Mac" is Message Authentication Code, which is used to make sure the integrity of data. It is generated by running the MAC engine on both sides. </t>

                <t>We will describe more detail information in the later section about the data transmission process.</t>
            </section>

            <section title=" PlsClose Packet">
                <t>This type of packet is used in closing the session between both sides. Since it indirectly inherits from PacketType class, it has DEFINITION_IDENTIFIER, DEFINITION_VERSION, and FIELDS attributes. We define FIELDS to be an optional "Error" type.
                </t>

                <t>If either client or server detects an error, it will send a PlsClose Packet with an error message. The text of the error message is implementation specific, but the presence of an error message indicates that it was not a normal termination. And also, when it comes to a normal shutdown, that is either the client end to the server end want to close the session, the "Error" field will be omitted. </t>
            </section>

            
        </section>

        <section title="Session Life">
            <section title="Session Establishment">
                <t>The Client sends the Server a hello, which is a PlsHello packet. This client hello contains a "Client-Nonce", which is 64 bits random number, and list of certificates. The first certificate must be root's certificate, followed by any other certificates required for authentication. Correspondingly, the server sends a hello to the client, which is the same type of package with the corresponding elements of the server side information. In this stage, both sides will make sure they are talking to the right person and they will also get the other side's public key.</t>
                
                <t>Then, in the next section in the handshake process, the Client sends the Server a Key Exchange Message, which is a PlsKeyExchange packet. This packet contains the Public key of the Client side (128 bits), and the Server-Nonce sent in the second phase plus one. In this phase, the Public key of the Client side is encrypted under the public key contained in Server's certificate. And the data that will be used by the client and the server to generate keys. Correspondingly, the server sends a hello to the client, which is the same type of package with the corresponding elements of the server side information.</t>
                <t>The client then sends a PlsHandshakeDone packet after the PlsKeyExchange packets are sent and received. The Handshake Finished Message contains the hash of the previous four handshake messages phase 1 through phase 4. It is the same as the server side, but they could send the PlsHandshakeDone package at the same time. </t>
                <t>After all the handshake process is finished, both side will accomplish authentication and generate the agreed symmetric encryption key.</t>
                <section title="Authentication ">
                    <t>In order to achieve the authentication of both side, we need to make the public key of both sides have a valid certification. In the PLSP, an authenticated party could generate other certifications for the lower level, and the highest level has to be the root. </t>
                </section>
                <section title="Key Derivation">
                    <t>They both side need to make an agreement on the symmetric key. They need to derive a Client Encryption Key, a server encryption key, which serves as the client's decryption key, a client MAC key and a server MAC key, which serves as the client's verification key. </t>
                    <t>Each type of the key is 128bits long. Besides, each side also has to generate a Client encryption IV and IVs Server encryption IV, each also of size 128bits.</t>
                    <t>To generate these keys and IVs, we need a consecutive hashing process. The first hash function seed is the ["PLS1.0" + Client-Nonce + Server Nonce + client public key + server public key]. We need to generate a stream using repeated SHA1 hashing of this seed. Then, we need to take the output of this hash function as the input seed of the SHA1 hashing stream. This process has to repeat for four times so that we could generate 800 bits data.</t>
                    <t>Then, in order to derive the keys and IVs from the data we got. These 800 bits can be cut up to create the 768 bits of keys and IV's described above (with 32 bits discarded). We take the first 128 bits to be AES encryption key of the client, the encryption key of the server is the next 128 bits, the following 128 bits is the IV of client side, the IV of the server is the 128 bits after, the MAC key of the client is the next 128 bits, and the MAC key of the server is the next 128 bits. Finally, the left 32 bits are discarded.</t>

                </section>
                <section title="Error Handling">
                <t>If either client or server detects an error, they are expected to terminate the session, because PLSP is above a reliable transmission layer, any transmission error is not likely happened naturally. And terminate this session is the most secure way to make sure confidentially transmission.</t>
                <t>PLSP should send a PlsClose packet with an error message. And when the other side of PSLP receive the package, it will also terminate its connection.  </t>
               
                </section>

                
            </section>
             <section title="Data Transmission">
                <t>After either side has sent the handshake complete message, it can begin to send data. Each side creates an encryption and decryption engine corresponding with keys and IV:
                </t>
                <t>For the client, the encryption engine is configured with client encryption key EKc and client IVc as the initial counter value. The decryption engine is configured with server decryption key EKs and server IVs as the initial counter value.</t>
                <t>For the server, the keys and IV's are reversed between the two engines. 
                Each side also creates an HMAC-SHA1 MAC engine and Verification engine.
                </t>
                <t>For the client, the MAC engine is configured with key MKc. The verification engine is configured with key MKs.</t>
                <t>For the server, the keys are reversed between the two engines. The encryption engine is configured with server encryption key EKc and client IVc as the initial counter value. The decryption engine is configured with client decryption key EKs and server IVs as the initial counter value.</t>
                <t>To send data, the plain text P is encrypted by the encryption engine to produce cipher text C. C is then passed to the MAC engine to produce verification code V. This data is sent in a PLS Data message (C, V).</t>
                <t>When data is received, C is extracted and passed to the Verification engine to produce reference verification code V'. If V does not match V', the packet is discarded, but the connection does not need to be closed. However, an implementation can choose to terminate the connection according to its own policy (e.g., if too many bad packets are received in a row). If it closes the connection abnormally, it MUST send a PlsClose packet with an error message of its choosing.</t>
                <t>If V == V', the ciphertext C is passed to the Decryption engine to produce P'. This data is passed to the higher layer.</t>
                <t>All data is encrypted using AES-128 in CTR mode. The encryption engine should be configured with the IV as the initial counter (IVc for client, IVs for server).</t>
                <t>Data sent must be encrypted with the appropriate encryption key (EKc for client, EKs for server). The cipher text is then MAC'd using HMAC-SHA1.</t>
                <t> 
                Either side can close the session. To do so, it MUST send a PlsClose packet. If it is a normal shutdown, it MUST send the PlsClose packet without any error message.
                If either side receive an error message, they MUST shut down the connection.
                </t>
            </section>

            

            <section title="Session Termination">
                <t>Both the client and the server can request termination by sending a PlsClose packet.
                When one side wants to close the session after all the data has been send successfully, it sends out a PlsClose packet to another side without the error message. The other side receives the packet and then closes.
                </t>
                <t>If the client side or the server side receives an error message during handshake or data transmission, for example, an unexpected nounce or certification, it knows that there exists an error. It must send a PlsClose packet to another side with a string type message to explain what the error is. This procedure terminates the session. The connection is closed to avoid error.</t>
       
            </section>
        </section>
    </middle>
    <!--  *****BACK MATTER ***** -->
    <back>
        <references title="Normative References">
            &RFC5246;
        </references>
        <!-- Change Log

v00 2006-03-15  EBD   Initial version

v01 2006-04-03  EBD   Moved PI location back to position 1 -
                     v3.1 of XMLmind is better with them at this location.
v02 2007-03-07  AH    removed extraneous nested_list attribute,
                     other minor corrections
v03 2007-03-09  EBD   Added comments on null IANA sections and fixed heading capitalization.
                     Modified comments around figure to reflect non-implementation of
                     figure indent control.  Put in reference using anchor="DOMINATION".
                     Fixed up the date specification comments to reflect current truth.
v04 2007-03-09 AH     Major changes: shortened discussion of PIs,
                     added discussion of rfc include.
v05 2007-03-10 EBD    Added preamble to C program example to tell about ABNF and alternative 
                     images. Removed meta-characters from comments (causes problems).

v06 2010-04-01 TT     Changed ipr attribute values to latest ones. Changed date to
                     year only, to be consistent with the comments. Updated the 
                     IANA guidelines reference from the I-D to the finished RFC.  
                     
SETH NIELSON:
  Altered for PLAYGROUND AND PRFC's
  2016-09-21 SJN PRFC 1

  Updated for Fall 2017
  2017-10-1

Qiyang Gu:
  PRFC 2: PEEP
  Updated 2017-10-14
  -->
    </back>
</rfc>
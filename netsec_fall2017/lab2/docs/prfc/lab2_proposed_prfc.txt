


Network Working Group                                            Gu, Ed.
Request for Comments: 2                                               Li
Category: Standards Track                                             Li
                                                                     Qin
                                                                     Xie
                                          JHU Network Security Fall 2017
                                                            October 2017


                    Playground Request For Comments

Abstract

   The PEEP (Players Enjoy Eavesdropping Protocol) is designed to
   provide a reliable, secure, connection-oriented transport layer
   mechanism for application layer and Playground.  This PRFC specifies
   the architecture and detailed implementations of PEEP.

Status of this Memo

   This document specifies a Playgrounds standards track protocol for
   the Playground Experiment, and requests discussion and suggestions
   for improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (c) 2017 SETH JAMES NIELSON.  All rights reserved.

   This document is used solely for educational purposes.  Any citations
   within this document are also for educational purposes and also for
   technical reference.  If any of these cited elements are protected
   under copyright, their inclusion here falls under Fair Use
   provisions.


















Gu, et al.                   Standards Track                    [Page 1]

RFC 2                            PRFC's                     October 2017


Table of Contents

   1.  INTRODUCTION . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.2.  Scope  . . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.3.  About this Document  . . . . . . . . . . . . . . . . . . .  4
     1.4.  Interfaces . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.5.  Operation  . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  PHILOSOPHY . . . . . . . . . . . . . . . . . . . . . . . . . .  6
     2.1.  Elements of the Internetwork System  . . . . . . . . . . .  6
     2.2.  Model of Operation . . . . . . . . . . . . . . . . . . . .  6
     2.3.  Interfaces . . . . . . . . . . . . . . . . . . . . . . . .  6
     2.4.  Relation to Other Protocols  . . . . . . . . . . . . . . .  7
     2.5.  Reliable Communication . . . . . . . . . . . . . . . . . .  7
     2.6.  Connection Establishment and Clearing  . . . . . . . . . .  7
     2.7.  Data Communication . . . . . . . . . . . . . . . . . . . .  8
     2.8.  Robustness Principle . . . . . . . . . . . . . . . . . . .  8
   3.  FUNCTIONAL SPECIFICATION . . . . . . . . . . . . . . . . . . .  8
     3.1.  Packet Type  . . . . . . . . . . . . . . . . . . . . . . .  8
     3.2.  Computational Algorithms . . . . . . . . . . . . . . . . .  9
     3.3.  Transition States  . . . . . . . . . . . . . . . . . . . .  9
     3.4.  Establishing a connection  . . . . . . . . . . . . . . . . 11
     3.5.  Data transmission  . . . . . . . . . . . . . . . . . . . . 12
     3.6.  Closing a Connection . . . . . . . . . . . . . . . . . . . 15
     3.7.  Interfaces . . . . . . . . . . . . . . . . . . . . . . . . 15
   4.  Normative References . . . . . . . . . . . . . . . . . . . . . 17
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 17
   Intellectual Property and Copyright Statements . . . . . . . . . . 18























Gu, et al.                   Standards Track                    [Page 2]

RFC 2                            PRFC's                     October 2017


1.  INTRODUCTION

   The Players Enjoy Eavesdropping Protocol (PEEP) is intended for use
   as a highly reliable host-to-host protocol between hosts in packet-
   switched computer communication networks, and in interconnected
   systems of such networks.

   This document describes the functions to be performed by the Players
   Enjoy Eavesdropping Protocol, the idea that designs it, the program
   that implements it, and its interface to the upper applications,
   programs, or the users that require its services.

   The format of this document, as well as many terminologies in this
   document, is referred to Requests for Comments: 793 Transmission
   Control Protocol.[RFC0793] Also, the implementations of PEEP are
   based on the implementations of Transmission Control Protocol.

1.1.  Motivation

   The purpose of the PEEP is to provide means of interconnecting
   computer communication networks and to provide standard interprocess
   communication protocols which can support a broad range of
   applications.  The name Players Enjoy Eavesdropping Protocol shows
   that this protocol is designed not only for the communication of
   applications but also for providing an approach to learn the security
   issues in the computer networks.

   PEEP is a connection-oriented, end-to-end reliable protocol designed
   to fit into a layered hierarchy of protocols.  The PEEP fits into a
   layered protocol architecture just above the Playground overlay
   network, which provides a way for PEEP to send and receive data
   packets that encapsulated by the Playground.  The Playground network
   that under the PEEP can be considered as a typical local area
   network.  To access the Playground network, we will need a Virtual
   Network Interface Card(VNIC) to provide connectivity to the network.

                       +----------------------------+
                       |         Higher-Layer       |
                       +----------------------------+
                       |            PEEP            |
                       +----------------------------+
                       |  Playground Wire Protocol  |
                       +----------------------------+
                       |    Lower-Layer Network     |
                       +----------------------------+

                             Protocol Layering




Gu, et al.                   Standards Track                    [Page 3]

RFC 2                            PRFC's                     October 2017


1.2.  Scope

   The PEEP is intended to provide a reliable process-to-process
   communication service above the Playground framework.  The PEEP is
   intended to be a host-to-host protocol in common use.

1.3.  About this Document

   This document represents a specification of the behavior required of
   any PEEP implementation, both in its interactions with higher level
   protocols and in its interactions with other PEEPs.  The rest of this
   section offers a very brief view of the protocol interfaces and
   operation.  Section 2 summarizes the philosophical basis for the PEEP
   design.  Section 3 offers a detailed and thorough description of the
   actions required of the PEEP when various events occur (arrival of
   new packets, the arrival of out-of-order packets, the arrival of
   damaged packets, etc.) and the details of the formats of PEEP
   packets.

1.4.  Interfaces

   The PEEP interfaces on one side to higher level protocol and on the
   other side to lower level protocol such as Playground wire protocol.

   The interface between higher level protocol and the PEEP consists of
   a set of calls.  For example, there are calls to make or close
   connections and to send and receive data on established connections.
   And the PEEP is also implemented asynchronously that allowing the
   higher level protocol to call the interface functions asynchronously,
   which means that when higher protocol to the user the interfaces to
   make a connection, a specific PEEP protocol will be created to handle
   this connection.  When implementing the PEEP interface, there is a
   minimum functionality that required for all the PEEP implementors to
   ensure that the PEEP interfaces are meet the minimum functional
   requirements.

   The interface between PEEP and lower level protocol, Playground wire
   protocol, is essentially unspecified except that it is assumed there
   is a mechanism whereby the two levels can asynchronously pass
   information to each other.  The PEEP is designed to work in a very
   general environment of interconnected networks.

1.5.  Operation

   As noted above, the primary purpose of the PEEP is to provide
   reliable connection service between pairs of processes.  To provide
   this service on top of a less reliable network communication system
   requires facilities in following areas:



Gu, et al.                   Standards Track                    [Page 4]

RFC 2                            PRFC's                     October 2017


      Basic Data Transfer

      Reliability

      Connections

   The basic operation of the PEEP in each of these areas is described
   in the following paragraphs.

      Basic Data Transfer:

      The PEEP is able to transfer a continuous stream of bytes of
      packets in each direction between its users by packaging some
      number of outlets into packets for transmission through the
      internet system.  In other words, the PEEP provides users with a
      basic service of data transmission that allows both sides can
      exchange data.  A continuous stream of bytes that are passed to
      PEEP will be divided into different chunks that each chunk has the
      same bytes.

      Reliability:

      The PEEP must recover from data that is damaged, lost, duplicated,
      or delivered out of order by the internet communication system.
      This is achieved by assigning a sequence number to each PEEP
      packet transmitted and requiring a positive acknowledgment (ACK)
      from the receiving PEEP.  If the ACK is not received within a
      timeout interval, the data is retransmitted.  At the receiver, the
      sequence numbers are used to correctly order packets that may be
      received out of order and to eliminate duplicates.  Damage is
      handled by adding a checksum to each packet transmitted, checking
      it at the receiver, and discarding damaged packets.  Notes that
      the checksum only can identify the damage packets result from
      unintentional and natural damage during the transmission process,
      not the intentional modified or damaged packets.
      As long as the PEEPs continue to function properly and the
      internet system does not become completely partitioned, no
      transmission errors will affect the correct delivery of data.
      PEEP recovers from internet communication system errors.

      Connections:

      The reliability mechanisms require that PEEPs initialize and
      maintain certain status information for each data stream.  The
      combination of this information, including sequence numbers, slice
      window, is called a connection.  Each connection is uniquely
      specified by sessions identifying its two sides.
      When two processes wish to communicate, their PEEP's must first



Gu, et al.                   Standards Track                    [Page 5]

RFC 2                            PRFC's                     October 2017


      establish a connection (initialize the status information on each
      side).  When their communication is complete, the connection is
      terminated or closed to free the resources for other uses.
      Since connections must be established between unreliable hosts and
      over the unreliable internet communication system, a handshake
      mechanism with clock-based sequence numbers is used to avoid
      erroneous initialization of connections.


2.  PHILOSOPHY

2.1.  Elements of the Internetwork System

   The environment consists of hosts connected to networks.  Here, it is
   assumed that the networks may be local networks or virtual
   networks(e.g. class VM).  Besides, the networks are based on packet
   switching.  The Internetwork system provides two-way data flow
   between ports.

   The packet is used to transmit data between ports.  The format of
   data blocks will be wrapped in the PEEP.  Thus, we do not concern the
   format.

   Hosts are the sources and destinations of packets.  We can send and
   receive packets what we need via hosts.

2.2.  Model of Operation

   In this process, data is transmitted by calling on the PEEP and
   passing buffers.  The PEEP packages the buffers into segments and
   calls on the playground module to transmit them.  When the receivers
   receive the buffer, the receivers will notify the sender.  In the
   transmission, the PEEP ensures these segments are ordered.

   The playground module packages PEEP segments inside datagrams and
   transmit these datagrams to the destination module.

2.3.  Interfaces

   The PEEP/user interface provides for calls made by the user on the
   PEEP to OPEN or CLOSE a connection, to SEND or RECEIVE data.

   The PEEP/lower protocol interface provides calls to send and receive
   datagrams addressed to PEEP in hosts in the virtual environment.
   These calls have parameters for passing the address, security and
   other control information.





Gu, et al.                   Standards Track                    [Page 6]

RFC 2                            PRFC's                     October 2017


2.4.  Relation to Other Protocols

   In the following, the diagram illustrates the place of the PEEP:

                 +------+  +------+
                 |client|  |server|          Application Level
                 +------+  +------+
                     |         |
                 +------+  +------+
                 | PEEP |  | PEEP |          PEEP Level
                 +------+  +------+
                     |         |
             +------------------------+
             |        Playground      |      Lower Level
             +------------------------+

                          Protocol Relationships

   It is expected that the PEEP will have the ability to support higher
   level protocols.

2.5.  Reliable Communication

   A stream of data sent on a PEEP connection is delivered reliably and
   in order at the destination.

   Transmission is made reliable via the use of sequence numbers and
   acknowledgments.  The sequence number of the first octet of data in a
   segment is transmitted with that segment and is called the segment
   sequence number.  When a segment is received, the receiver will
   return an acknowledgement number which is the sequence number of its
   next expected data.  When the PEEP transmits a segment containing
   data, it puts a copy on a retransmission heap and starts a timer;
   when the acknowledgment for that data is received, the segment is
   deleted from the heap.  If the acknowledgment is not received before
   the timer runs out, the segment is retransmitted.

   To govern the flow of data between PEEPs, a fixed-size "window" is
   set to identify the maximum numbers of segments that can be
   transmitted at a time.

2.6.  Connection Establishment and Clearing

   The procedures to establish connections utilize the synchronize(SYN)
   control flag and involves an exchange of three messages.  This
   exchange has been termed a three-way handshake.  When the sequence
   numbers have been synchronized in both directions, the connection is
   established.



Gu, et al.                   Standards Track                    [Page 7]

RFC 2                            PRFC's                     October 2017


   The clearing of a connection also involves the exchange of segments.

2.7.  Data Communication

   The data flow on the connection can be considered as a stream of the
   buffer.  A sending PEEP is allowed to collect data from the sending
   user and to send that data in segments at its own convenience.

2.8.  Robustness Principle

   PEEP implementation will follow one general principle of robustness
   which followed by TCP: be conservative in what you do, be liberal in
   what you accept from others.


3.  FUNCTIONAL SPECIFICATION

3.1.  Packet Type

   The packet used for transmitting through PEEP is defined as the
   followings.  The packet includes information fields type, sequence
   number, acknowledgement, checksum, and data.

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      Type     |                   Padding                     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                        Sequence Number                        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                    Acknowledgment Number                      |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |           Checksum            |            Padding            |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                             data                              |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                            PPEP Header Format

   Each tick mark represents a bit position.

   Type: 8 bits

   Type indicates the type of a packet.  Type 0 indicates a SYN packet,
   Type 1 indicating a SYN-ACK packet, Type 2 indicating a ACK packet,
   Type 3 indicating a RIP packet, Type 4 indicating a RIP-ACK packet,
   Type 5 indicating a Data packet.




Gu, et al.                   Standards Track                    [Page 8]

RFC 2                            PRFC's                     October 2017


   Sequence Number: 32 bits

   Each packet has its sequence number to set the packets in order.

   Acknowledgment Number: 32 bits

   Each time a packet is received, the receiver will send back an
   acknowledgement.  Acknowledgement number is always the sequence
   number it is expecting to receive.

   Checksum: 16 bits

   The checksum is used to detect if the packet is completely received.
   The sender calculates the checksum before sending the packet and
   sends it alone with the packet.  When the receiver receives the
   packet, it calculates the checksum with the same calculation and
   compares the two checksum numbers.  If they are different, the
   receiver discards the packet.

   Data

   Data includes the actual data buffer from a higher layer.

3.2.  Computational Algorithms

      Generation of Sequence number:

      The first sequence number is an integer (SYN's sequence number)
      generated randomly from 0 to 2 to the 16.  The following sequence
      number is calculated by adding the sequence number and the length
      of the data in the last packet.

      Generation of Acknowledgement number:

      The acknowledgement number is equal to the sequence number for the
      receiver's next expecting packet.

      Generation of Checksum:

      The checksum for a packet is calculated by a Python library called
      zlib.  An Adler-32 checksum algorithm is provided by zlib.

3.3.  Transition States

   The figure below indicates the transition states according to the
   segments received and sent.





Gu, et al.                   Standards Track                    [Page 9]

RFC 2                            PRFC's                     October 2017


                           +---------------+
                           |    CLOSED     |
                           +----+-----+----+
                                |     |
                         SENT IN|     |  RECV INI, SENT INI/ACK
                                v     v
                           +---------------+
                           |    LISTEN     |
                           +----+-----+----+
                                |     |
          +---------------+     |     |       +---------------+
          | INITIATE SENT | ^---+     +------^| INITIATE RECV |
          |               | <---------------- |               |
          +----+------+---+   RECV/SENT ACK   +-------------+-+
               |      |                                     |
               |      | SENT ACK                   SENT ACK |
     TERMINATE |      |       +---------------+             |
               |      +-----> |   CONNECTED   | <-----------+
               |              +----+-----+----+
               |                   |     |
               v   CLOSE, SENT RIP |     |RECV RIP, SENT ACK
          +-----------------+      |     |           +------------+
          |    RIP WAIT-1   | <----+     +---------> | CLOSE WAIT |
          +----+-------+----+                        +---------+--+
               |       |                                       |
               |       +----------------+SENT ACK, RECV RIP    | CLOSE
               | RECV ACK               |                      |
               v                        v                      v
      +------------------+      +-------+------+      +--------+------+
      |     RIP WAIT-2   |      |   CLOSING    |      | LAST-ACK RECV |
      +------------------+      +-------+------+      +-------+-------+
               |                        |                     |
               |RECV RIP, SENT ACK      |RECV ACK             |RECV ACK
               |                        v                     v
               |           +---------------+      +---------------+
               +---------> |   TIME WAIT   | ---->|    CLOSED     |
                           +---------------+      +---------------+

                             Transition States

      LISTEN: This state is to be maintained by the receiver (server)
      while listening for a connection on any PEEP port and IP address

      INITIATE SENT: This state is to be maintained by the sender
      (client) after it starts a three-way handshake in which it sends
      an SYN and waits for an ACK back.





Gu, et al.                   Standards Track                   [Page 10]

RFC 2                            PRFC's                     October 2017


      INITIATE RECV: This state is to be maintained by the receiver
      (server) after it sends an SYN-ACK and waits for the sender's ACK.

      CONNECTED: This state is to be maintained by both sides after the
      handshake is successfully initialized.  Both server and client is
      ready to transmit data.

      RIP WAIT-1: This state is to be maintained by the sender in which
      it waits for a connection termination request from the receiver,
      or an acknowledgment of the connection termination request
      previously sent.

      RIP WAIT-2: This state is to be maintained by the sender in which
      it waits for a connection termination request from the receiver.

      CLOSE WAIT: This state is to be maintained by the receiver in
      which it waits for a connection termination request from the local
      user.

      CLOSING: This state is to be maintained by the sender in which it
      waits for a connection termination ACK from the receiver.

      LAST-ACK RECV: This state is to be maintained by the receiver in
      which it waits for an ACK of the connection termination request
      previously sent to the sender.

      TIME WAIT: This state is to be maintained by the receiver in which
      it waits for enough time to assure its ACK has been sent to the
      sender.

      CLOSED: This state means there exists no connection.  Both sides
      has been closed.

3.4.  Establishing a connection

   The three-way handshake similar to TCP is used to establish the
   connection between two sides.

   Before starting the process, the client side is closed and the server
   side is listening and waiting for incoming packets.  To establish a
   connection, the client side PEEP (refers as PEEPClient) first sends a
   SYN packet including its sequence number x.  When the sever side PEEP
   (refers as PEEPServer) sends back a SYN-ACK packet to PEEPClient.
   The packet includes its sequence number y as well as the
   acknowledgement which is the client side packet's sequence number
   plus one (x+1).  The acknowledgement is also the sequence number of
   the packet it is expected to receive.  After the PEEPClient receives
   the SYN-ACK packet, it calls its higher protocols to make a



Gu, et al.                   Standards Track                   [Page 11]

RFC 2                            PRFC's                     October 2017


   connection.  The PEEPClient also sends back an ACK packet to
   PEEPServer.  The packets include its updated sequence number (x+1)
   and acknowledgement y+1.  Notice that the sequence number here is the
   same with the SYN-ACK packet's acknowledgement, which means the
   PEEPClient sends the packet the PEEPServer is expected.  When the
   PEEPServer receives this packet, it calls its higher protocols to
   make a connection.  If either packet in this process is not received,
   the connection cannot be established.  After the three-way handshake,
   the whole connection is made and packets can be sent and received by
   both sides through the Playground.

3.5.  Data transmission

   The two parts of connection achieved data transmission by exchanging
   segments with each other.  The segments may be lost due to different
   errors, like checksum test failure, network congestion.  The PEEP
   implements a retransmit mechanism to ensure no error transmission.
   Duplicate segments maybe arrived due to network and PEEP packet
   retransmit.  In this situation, PEEP could distinguish the duplicate
   data by identifying the sequence number and decide whether to receive
   data and send an ACK packet.

   For every packet sent through the protocol, it always has a sequence
   number.  Each packet is sequenced by this sequence number and can be
   acknowledged.  When one side protocol receives a sequence number, it
   always sends back an acknowledgment X which is the next packet's
   sequence number it is expected to receive.  The acknowledgment
   represents the data octets up to but not including the sequence
   number X. So the next packet it received should be sequence number X.
   It will prevent duplicate and disorder of packets to some extent.  We
   pick the initial sequence number randomly from 0 to 2^16 to sequence
   the packets, the sequence number is never infinite, when programming,
   we should consider the valuable sequence number to count.

   There are some kinds of comparison needs to be included.

   1.  Acknowledgement always refers to the sequence number sent but not
       acknowledged yet.

   2.  All sequence numbers are acknowledged if sent successfully.

   3.  The incoming packet's sequence number is always expected as the
       previous acknowledged.

   In each packet transmission, it always has a sender's sequence number
   and a receiver's sequence number.  In our program, we randomly pick
   the initial sequence number for each side, the client, and server,
   and the following packet's sequence number of the same side will be



Gu, et al.                   Standards Track                   [Page 12]

RFC 2                            PRFC's                     October 2017


   defined based on the data size.  To establish the connection, the two
   sides exchanged the sequence number, which is stored in the SYN by
   sending back the acknowledgment.  The packets are sequenced based on
   this sequence number so that disorder and lots of packets can be
   detected.  To be more specific, we use the arrows to represents the
   packets sent along these two sides:

   1.  Client-Server SYN with sequence number X.

   2.  Server Client ACK acknowledge receiving sequence number X SYN
       with sequence number Y.

   3.  Client-Server ACK acknowledge receiving sequence number Y

   This can be treated as the "three-way handshake".  After these three
   ways to exchange packets, a connection can be established.  It's
   necessary because the server will not know which packet is actually
   working and may cause chaos.  Details of this "three-way handshake"
   will be introduced in next paragraph.

   In the data Transmission, the data sender keeps track of the next
   sequence number, and save it base on the local variable
   "_size_for_last_packet" and "_seq_num_for_last_packet".  The data
   receiver keeps track of the next sequence number to expect in its
   local variable "_seq_num_for_next_expected_packet".  The sender of
   data keeps saves the oldest unacknowledged packet in its variable
   heap "_disordered_packets_heap".  If the data flow is momentarily
   idle and all data sent has been acknowledged then the three variables
   will be equal.

   When data sender transmits a new packet, it will update its variable
   "_size_for_last_packet" and "_seq_num_for_last_packet" value, and it
   will preserve it as an unacknowledged packet in its list
   "_disordered_packets_heap".  On the other side, when the receiver
   gets the new packet, it will update its
   "_seq_num_for_next_expected_packet", the process that data packet and
   send an ACK packet to the data sender.  And as the sender received
   the ACK packet from the receiver, it will update its heap
   "_disordered_packets_heap", by removing this packet form the heap.
   In the real data transmission, such sequence did not happen at the
   same time, there will be some delay because of the network states or
   other reason.  And missing or bad packet will lead to the
   retransmission.

   Retransmission timeout.

   In PEEP, the retransmission time is 5 seconds, it is set according to
   the experience.  This retransmission time limit stays the same



Gu, et al.                   Standards Track                   [Page 13]

RFC 2                            PRFC's                     October 2017


   whenever the playground network condition changes.

   There are the most common two conditions of data retransmission.

          Sender ------------- Data packet ----------> X Receiver
          5 seconds later
          Sender ------------- Data packet ------------> Receiver
          Sender <------------ Data packet ------------- Receiver

   If the sender sends a packet, and it is being lost or compromised in
   the network, the receiver cannot give a response to this situation.
   And, after the sender waited for 5 seconds after it sends this data
   packet, it will automatically resend this packet to the receiver.

          Sender ------------- Data packet ------------> Receiver
          Sender X <---------- Data packet ------------- Receiver
          5 seconds later
          Sender ------------- Data packet ------------> Receiver
          Sender <------------ ACK packet ------------- Receiver

   The second common situation is that the receiver got the packet from
   the sender, and send an ACK packet to reply the sender.  However,
   this ACK packet may lose or compromised in the network.  In this
   situation, the sender cannot receive the ACK packet, and it will
   resend the Data packet after 5 seconds.  The server will reply to
   this resend packet, and resend ACK.

   Managing the Window.

   The window in PEEP protocol indicates the range of PEEP packet the
   sender is currently prepared to send without waiting for the ACK
   packet from the server.  The max window size in PEEP is related to
   the buffer space available for this connection, and the network
   condition of the connection.

   If the window is large, it will encourage data transmission.  But
   when in some situation, it may exceed the capability of the server to
   handle the coming packet, and this may lead to a lot of
   retransmission.  The extra load may be added to the network in this
   situation.  On the other hand, if the window is too small, the sender
   may remain to do nothing until accepted the receiver reply ACK.  In
   this case, the small window restricts the transmission efficiency.

   In the PEEP protocol, we implement the static transmission window.
   Because the playground network environment is more stable and less
   fluctuate compare to the real network environment of TCP protocol.
   We could set the max window size based on our experience.




Gu, et al.                   Standards Track                   [Page 14]

RFC 2                            PRFC's                     October 2017


   Window implementation.

   Every time the sender would like to send a packet, it will check its
   unacknowledged heap "_disordered_packets_heap" to see if the heap has
   reached the max window size.  If not, it will send the packet and
   preserve it in the heap "_disordered_packets_heap".  Else, if the
   heap size is less than the max window value, the sender will save the
   packet in the backlog, and wait for the window to move forward.

   Once the receiver received a packet, it will send an ACK to inform
   the sender the current state of the receiver.  So that the sender
   will move the window forward, and pop the acknowledged packet out of
   "_disordered_packets_heap" heap.

3.6.  Closing a Connection

   When the client cleans its buffer and gets ready to terminate the
   connection, it will send out a RIP packet with sequence number X to
   the server.  And the server sends back a RIP-ACK packet with sequence
   number X+1.  And then, the server side will clean its buffer and send
   back to the client a RIP packet with sequence number Y. Next, that
   when the client receives the RIP packet, it sent backs the last RIP-
   ACK packet with sequence number Y+1 and closes.  The last step is
   that when the server received the RIP-ACK packet, it closes.

        PEEP Client                                         PEEP Server
     1.  ESTABLISHED                                        ESTABLISHED
     2.  (Close)
         RIP-WAIT-1 --> <SEQ=100><ACK=300><TYPE=3>    -->   CLOSE-WAIT
     3.  RIP-WAIT-2 <-- <SEQ=300><ACK=101><TYPE=4>    <--   CLOSE-WAIT
     4.                                                      (Close)
         TIME-WAIT  <-- <SEQ=300><ACK=101><TYPE=3>    <--    LAST-ACK
     5.  TIME-WAIT  --> <SEQ=101><ACK=301><TYPE=4>    -->     CLOSED
     6.  (2 MSL)
         CLOSED

                          Connection Termination

3.7.  Interfaces

   The PEEP protocol provides interfaces for the upper protocol and the
   possible lower protocol.  We will have a fairly elaborate model to
   discuss the upper-level/PEEP interface, but for the possible lower,
   we do not look into the details.  And that may be discussed in the
   lower level protocol document.

   Upper-level/PEEP Interface




Gu, et al.                   Standards Track                   [Page 15]

RFC 2                            PRFC's                     October 2017


   The upper-level protocol commands described below specify the basic
   functions the PEEP must perform to support interprocess
   communication.

      Connection made:

      The PEEP protocol provides the interface to the upper level make
      connection method.  The upper class passes the destination address
      and port, and the PEEP makes a connection with the PEEP in the
      other side.  Once the connection is made, the PEEP will pass a
      PEEP transport to the upper level.

      Data sent:

      The PEEP protocol provides the interface to the upper-level data
      write method.  The upper class passes the buffer stream to the
      PEEP and the PEEP chunked the buffer stream according to the pre-
      defined size.  And transmit these data chunk to PEEP on the other
      side.  If there is a lower level, it will receive the buffer
      stream from the PEEP.  Once the data is written, the PEEP will get
      the data with PEEP transport on the upper level.

      In the data send, every data packet will be saved until the PEEP
      received the ACK packet from the receiver to report current needed
      packet.  If this packet is already received by the other side, the
      sender will find out by analyzing the ACK number in the ACK
      packet.  And it will retransmit some packet when the timeout
      happened.

      Data received:

      The PEEP protocol provides the interface to the upper-level data
      to the expect buffer stream of certain packets.  Once the PEEP
      received data, which could be disordered, it will reorder the
      buffer stream base on their sequence number.  Then PEEP connects
      the chunked buffer according to the right order, and it will pass
      the correct stream to the upper level.  Once the data is re-
      ordered and connected, the PEEP will pass the data with calling
      the data_received function on the upper level.

      If there are some missing packet in the data re-order section, the
      PEEP in the receiver side will wait for the sender to pass the
      missing packet.  Different ACK may be sent by the receiver, in
      which it only writes the missing packet's sequence number whenever
      what sequence number packet it received.






Gu, et al.                   Standards Track                   [Page 16]

RFC 2                            PRFC's                     October 2017


4.  Normative References

   [RFC0793]  Postel, J., "Transmission Control Protocol", STD 7,
              RFC 793, DOI 10.17487/RFC0793, September 1981,
              <https://www.rfc-editor.org/info/rfc793>.


Authors' Addresses

   Qiyang Gu (editor)
   JHU Network Security Fall 2017

   Phone: +1 443-939-5604
   Email: qiyanggu@jhu.edu


   Binjie Li
   JHU Network Security Fall 2017

   Phone: +1 443-563-8366
   Email: bli38@jhu.edu


   Zhiyuan Li
   JHU Network Security Fall 2017

   Phone: +1 443-531-9661
   Email: zli108@jhu.edu


   Qinmeng Qi
   JHU Network Security Fall 2017

   Phone: +1 443-938-6891
   Email: mqin2@jhu.edu


   Yiming Xie
   JHU Network Security Fall 2017

   Phone: +1 443-635-9868
   Email: yxie32@jh.edu









Gu, et al.                   Standards Track                   [Page 17]

RFC 2                            PRFC's                     October 2017


Full Copyright Statement

   Copyright (C) Seth James Nielson (2017).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the PLAYGROUND experiment or
   other associated organizations, except by explicit permission.

   The limited permissions granted above are perpetual and will not be
   revoked by SETH JAMES NIELSON or his successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and SETH JAMES NIELSON and associated academic
   institutions DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The PLAYGROUND framework and student submissions for PLAYGROUND are
   intended to be free of any intellectual property conflicts.  All
   submitting parties, especially students, are not allowed to submit
   source code, specifications, or other components that are known to be
   protected by copyright, patents, or other IP mechanisms.  Students
   submitting creative content grant shared rights and ownership of
   their content to the PLAYGROUND project.  Specifically, any
   submission can be used in future educational settings including
   subsequent PLAYGROUND experiments.

   Any interested party is invited to bring to the experiment director's
   attention any copyrights, patents or patent applications, or other
   proprietary rights which may cover technology that may be currently
   in use without permission.

   It should be noted that these statements have not been reviewed by
   legal counsel.  Moreover, the academic institutions at which
   PLAYGROUND experiments take place may have additional or even
   conflicting copyright and intellectual property rules.  Accordingly,
   concerned parties may need to contact their own lawyer and/or
   resources at their institution to understand the rights and



Gu, et al.                   Standards Track                   [Page 18]

RFC 2                            PRFC's                     October 2017


   limitations associated with code donated to a PLAYGROUND experiment.


















































Gu, et al.                   Standards Track                   [Page 19]

